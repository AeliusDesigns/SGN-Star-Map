<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SGN — 3D Star Map (Core / Mid / Outer)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0e13; color:#e8e6df; font-family:system-ui,Segoe UI,Arial; }
    #app { position:fixed; inset:0; }
    .hud {
      position:fixed; top:12px; left:12px; padding:10px 12px; background:#1117; border:1px solid #333; border-radius:10px; backdrop-filter: blur(4px);
      font-size:14px; line-height:1.4;
    }
    .hud code { background:#0006; padding:0 6px; border-radius:6px; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div><strong>SGN Star Map</strong> — drag to orbit, wheel to zoom, right-drag to pan.</div>
    <div>Owner: <code>Arandorë Eldainë</code> (all systems)</div>
  </div>

  <!-- Three.js + OrbitControls (ESM CDNs) -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js";

    // Boot the scene
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e13);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 50000);
    camera.position.set(0, 0, 1500);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Subtle lights
    const key = new THREE.DirectionalLight(0xffffff, 0.6); key.position.set(1,1,1);
    const fill = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(key, fill);

    // Helpers (grid for reference; you can toggle off)
    // const grid = new THREE.GridHelper(2400, 24, 0x333333, 0x222222);
    // grid.rotation.x = Math.PI/2; scene.add(grid);

    // Load systems
    const url = "./systems.json";  // keep this filename in your repo
    const ownerName = "Arandorë Eldainë";

    fetch(url).then(r => r.json()).then(data => {
      // Determine scale from image size if present; otherwise default to 2000x2000 “plane”
      const imgW = data?.image_size?.width  ?? 1090;
      const imgH = data?.image_size?.height ?? 1494;

      const SCALE = 2200; // world units across
      const aspect = imgW / imgH;
      const worldW = SCALE;
      const worldH = SCALE / aspect;

      // Core/Mid/Outer rough Z bands (you can refine once we tag rings)
      const Z_CORE =   0;
      const Z_MID  = 150;
      const Z_OUT  = 300;

      // Materials
      const matCore  = new THREE.MeshBasicMaterial({ color: 0xffdd88 });
      const matMid   = new THREE.MeshBasicMaterial({ color: 0xffb84d });
      const matOuter = new THREE.MeshBasicMaterial({ color: 0xff9944 });

      const sphere = new THREE.SphereGeometry(6, 16, 16);

      // If rings aren’t tagged yet, place everything on a single z-layer;
      // later we’ll switch Z by ring classification.
      const guessZ = (sys) => Z_CORE;

      // Draw nodes
      const group = new THREE.Group();
      data.systems.forEach(sys => {
        // Prefer normalized; fall back to pixel if needed
        let xn = sys.coords?.x_norm;
        let yn = sys.coords?.y_norm;

        if (xn == null || yn == null) {
          // compute from pixel positions (origin top-left)
          const px = sys.pixel?.x ?? 0;
          const py = sys.pixel?.y ?? 0;
          xn = px / imgW;
          yn = py / imgH;
        }

        // Convert 0..1 into world coords centered at (0,0)
        const x = (xn - 0.5) * worldW;
        const y = -(yn - 0.5) * worldH; // invert Y so top goes +Y visually
        const z = guessZ(sys);

        const material =
          z === Z_CORE ? matCore :
          z === Z_MID  ? matMid  :
                         matOuter;

        const dot = new THREE.Mesh(sphere, material);
        dot.position.set(x, y, z);
        dot.userData = { id: sys.id, name: sys.name, owner: sys.owner || ownerName };
        group.add(dot);
      });

      scene.add(group);

      // A faint backdrop disk (optional aesthetic)
      const diskGeo = new THREE.CircleGeometry(Math.max(worldW, worldH)*0.58, 64);
      const diskMat = new THREE.MeshBasicMaterial({ color: 0x0f141d, transparent:true, opacity:0.8 });
      const disk = new THREE.Mesh(diskGeo, diskMat);
      disk.rotation.x = -Math.PI/2;  // lay flat? comment out to keep frontal
      disk.visible = false;          // off by default
      // scene.add(disk);

      // Simple hover tooltip
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const tip = document.createElement('div');
      tip.style.cssText = "position:fixed;padding:6px 8px;background:#111c;border:1px solid #444;border-radius:8px;pointer-events:none;display:none;color:#fff;font:12px/1.3 system-ui";
      document.body.appendChild(tip);

      function onMove(e){
        mouse.x =  (e.clientX / window.innerWidth)  * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hit = raycaster.intersectObjects(group.children, false)[0];
        if(hit){
          const d = hit.object.userData;
          tip.innerHTML = `<strong>${d.name}</strong><br/>Owner: ${d.owner}<br/><small>${d.id}</small>`;
          tip.style.left = (e.clientX + 12) + "px";
          tip.style.top  = (e.clientY + 12) + "px";
          tip.style.display = 'block';
        } else {
          tip.style.display = 'none';
        }
      }
      window.addEventListener('mousemove', onMove);
    });

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Loop
    (function loop(){
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
